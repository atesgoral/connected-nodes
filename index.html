<style>
html, body {
  height: 100%;
}
body {
  margin: 0;
  padding: 0;
  background: -webkit-gradient(linear, right top, left bottom, from(#3bbdec), to(#00aae7));
}
canvas {
  width: 100%;
  height: 100%;
}
#text {
  position: absolute;
  top: 50%;
  margin-top: -24pt;
  width: 100%;
  text-align: center;
  color: #fff;
  font-family: Helvetica, sans-serif;
  font-size: 48pt;
}
#overlay {
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  left: 0;
  background: url(Header.png) 50% 50% no-repeat;
  background-size: 40%;
}
</style>
<canvas>
</canvas>
<div id="overlay"></div>
<script>
var NODE_COLOR = '#fff';
var WAVE_COLOR = '#fff';
var CONNECTION_COLOR = '#fff';

var SPAWN_DURATION = 500;
var SPAWN_STEPS = [{
  d: 3000,
  r: 0.25,
  n: 10
}, {
  d: 1000,
  r: .5,
  n: 50
}, {
  d: 1000,
  r: 1,
  n: 100
}];
var CONNECTION_DURATION = 4000;
var CONNECTION_MAX_DISTANCE = 200;
var MAX_CONNECTIONS_PER_NODE = 2;

var NODE_RADIUS = 2;
var NODE_VELOCITY = 0.075;
var NODE_SILENT_DURATION = 40000;

var WAVE_MAX_DURATION = 2500;
var WAVE_MAX_DISTANCE = 30;

window.onload = function () {
  var canvas = document.getElementsByTagName('canvas')[0];

  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;

  var ctx = canvas.getContext('2d');

  var nodes = [];

  function process() {
    var now = Date.now();

    nodes.forEach(function (node, idx) {
      node.x += Math.cos(node.a) * node.v;
      node.y += Math.sin(node.a) * node.v;

      // node.x = (node.x + canvas.width / 2) % canvas.width - canvas.width / 2;
      // node.y = (node.y + canvas.height / 2) % canvas.height - canvas.height / 2;

      if (node.x < - canvas.width / 2 || node.x > canvas.width / 2) {
        node.a = Math.PI - node.a;
      }

      if (node.y < - canvas.height / 2 || node.y > canvas.height / 2) {
        node.a = 2 * Math.PI - node.a;
      }

      var elapsed = now - node.t;

      for (var otherIndex in node.connections) {
        var connection = node.connections[otherIndex];

        if (connection && connection.disconnecting && now - connection.t >= CONNECTION_DURATION) {
          delete node.connections[otherIndex];
        }
      }

      switch (node.state) {
      case 'HIDING':
        if (elapsed >= node.hideDuration) {
          node.state = 'SPAWNING';
          node.t = now;
        }
        return;
      case 'SPAWNING':
        if (elapsed >= SPAWN_DURATION) {
          node.state = 'SILENT';
          node.t = now - Math.random() * NODE_SILENT_DURATION;
        }
        return;
      case 'SILENT':
        if (elapsed >= NODE_SILENT_DURATION) {
          node.waves.push({
            t: now,
            delay: 0
          }, {
            t: now,
            delay: WAVE_MAX_DURATION / 3
          }, {
            t: now,
            delay: WAVE_MAX_DURATION / 3 * 2
          });
          node.waves.length = Math.floor(Math.random() * 3) + 1;
          node.state = 'EMITTING';
          node.t = now;
        }
        break;
      case 'EMITTING':
        node.waves = node.waves.filter(function (wave) {
          return now - wave.delay - wave.t <= WAVE_MAX_DURATION
        });

        if (!node.waves.length) {
          node.state = 'SILENT';
          node.t = now;
        }
        break;
      }

      nodes.forEach(function (otherNode, otherIdx) {
        if (otherNode.state === 'HIDING' || otherNode.state === 'SPAWNING') {
          return;
        }

        var dx = node.x - otherNode.x;
        var dy = node.y - otherNode.y;
        var d = Math.sqrt(dx * dx + dy * dy);
        var connection = node.connections[otherIdx];

        if (d <= CONNECTION_MAX_DISTANCE) {
          if (connection) {
            if (now - connection.t >= CONNECTION_DURATION) {
              connection.connecting = false;
            }
          } else {
            var otherNode = nodes[otherIdx];

            if (
              otherIdx !== idx
              && !otherNode.connections[idx]
              && Object.keys(node.connections).length < MAX_CONNECTIONS_PER_NODE
              && Object.keys(otherNode.connections).length < MAX_CONNECTIONS_PER_NODE
            ) {
              node.connections[otherIdx] = {
                connecting: true,
                t: now
              };
            }
          }
        } else {
          if (connection && !connection.disconnecting && !connection.connecting) {
            connection.disconnecting = true;
            connection.t = now;
          }
        }
      });
    });
  }

  function paint() {
    var now = Date.now();

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    nodes.forEach(function (node) {
      if (node.state === 'HIDING') {
        return;
      }

      if (node.state === 'SPAWNING') {
        ctx.globalAlpha = Math.max(0, now - node.t) / SPAWN_DURATION;
      }

      ctx.fillStyle = NODE_COLOR;
      ctx.beginPath();
      ctx.arc(
        canvas.width / 2 + node.x,
        canvas.height / 2 + node.y,
        node.r,
        0,
        Math.PI * 2
      );
      ctx.fill();

      ctx.globalAlpha = 1;

      for (var otherIdx in node.connections) {
        var connection = node.connections[otherIdx];

        if (!connection) {
          continue;
        }

        var otherNode = nodes[otherIdx];

        if (connection.connecting) {
          ctx.globalAlpha = Math.min(1, (now - connection.t) / CONNECTION_DURATION);
        } else if (connection.disconnecting) {
          ctx.globalAlpha = 1 - Math.min(1, (now - connection.t) / CONNECTION_DURATION);
        }

        ctx.strokeStyle = CONNECTION_COLOR;
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2 + node.x, canvas.height / 2 + node.y);
        ctx.lineTo(canvas.width / 2 + otherNode.x, canvas.height / 2 + otherNode.y);
        ctx.stroke();

        ctx.globalAlpha = 1;
      };

      node.waves.forEach(function (wave) {
        var elapsed = now - wave.delay - wave.t;

        if (elapsed < 0) {
          return;
        }

        var n = Math.max(0, WAVE_MAX_DURATION - elapsed) / WAVE_MAX_DURATION;

        ctx.globalAlpha = n;
        ctx.strokeStyle = WAVE_COLOR;
        ctx.beginPath();
        ctx.arc(
          canvas.width / 2 + node.x,
          canvas.height / 2 + node.y,
          node.r + (1 - n) * WAVE_MAX_DISTANCE,
          0,
          Math.PI * 2
        );
        ctx.stroke();
      });

      ctx.globalAlpha = 1;
    });
  }

  function tick() {
    paint();
    process();
    setTimeout(tick, 1000 / 50);
  }

  function spawnNode(spawnMinRadius, spawnMaxRadius, maxHideDuration) {
    var a = Math.random() * Math.PI * 2;
    var r = (spawnMaxRadius - spawnMinRadius) * Math.random() + spawnMinRadius;
    var newNode = {
      x: Math.cos(a) * r * canvas.width / 2,
      y: Math.sin(a) * r * canvas.height / 2,
      a: 2 * Math.PI * Math.random(),
      v: NODE_VELOCITY,
      r: NODE_RADIUS,
      t: Date.now(),
      waves: [],
      state: 'HIDING',
      hideDuration: maxHideDuration * Math.random(),
      connections: {}
    };

    nodes.push(newNode);
  }

  var prevMinRadius = 0;

  function spawnNodes() {
    var spawnStep = spawnSteps[0];

    for (var i = 0; i < spawnStep.n; i++) {
      spawnNode(prevMinRadius, spawnStep.r, spawnStep.d);
    }

    prevMinRadius = spawnStep.r;
    spawnSteps.shift();

    if (spawnSteps.length) {
      setTimeout(spawnNodes, spawnStep.d);
    }
  }

  var spawnSteps = SPAWN_STEPS;

  spawnNodes();

  tick();
};
</script>
